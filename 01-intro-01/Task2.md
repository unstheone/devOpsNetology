Чтобы лучше понимать предназначение дальнейших инструментов, с которыми нам предстоит работать, давайте составим схему жизненного цикла задачи в идеальном для вас случае.

# Описание истории

Представьте, что вы работаете в стартапе, который запустил интернет-магазин. Ваш интернет-магазин достаточно успешно развивался, и вот пришло время налаживать процессы: у вас стало больше конечных клиентов, менеджеров и разработчиков.Сейчас от клиентов вам приходят задачи, связанные с разработкой нового функционала. Задач много, и все они требуют выкладки на тестовые среды, одобрения тестировщика, проверки менеджером перед показом клиенту. В случае необходимости, вам будет необходим откат изменений.

# Задача
Вам необходимо описать процесс решения задачи в соответствии с жизненным циклом разработки программного обеспечения. Использование какого-либо конкретного метода разработки не обязательно. Для решения главное - прописать по пунктам шаги решения задачи (релизации в конечный результат) с участием менеджера, разработчика (или команды разработчиков), тестировщика (или команды тестировщиков) и себя как DevOps-инженера.

# Ответ

1. Систематизировать поток приходящих от клиентов задач, желательно с разделением по "источнику" задачи (внешний пользователь, разработчик, менеджмент). Придумать систему объединения задач (когда разные пользователи просят схожий/такой же функционал) и их категоризирование по срочности, важности, сложности и т.д. Лучше это делать сразу с использованием инструмента вроде "Aha!" - так не придётся переносить идеи вручную, а пользователи смогут видеть уже зарегистрированные "идеи".
2. Организовать review заявок на еженедельной (или раз в две недели) основе проектной командой, чтобы формировать очередь попадания в разработку тех или иных задач. В команде должны быть точно team lead разработки, product owner (ответственный менеджер продукта) и devops.
3. Обеспечить попадание отобранных заявок в очередь разработки. N-ное количество заявок должно обратиться в некий release-plan, который даст всем участникам понимание, что ожидать при ближайшем обновлении. Для этого всего может подойти confluence.
4. Возможно, нужна dev среда для разработки, копирующая функционал реального интернет-магазина, но работающая только с тестовой базой данных.
5. Создание staging окружения
6. По мере готовности нового кода и прохождения внутреннего тестирования, необходимо обеспечить доставку этого кода на staging. Тестировщики проверяют новый функционал и либо возвращают на доработку, либо дают одобрение.
7. При достижении достаточного (или необходимого) количества изменений, все накопленные изменения тестируются вместе, и, при успешном результате, демонстрируются менеджеру (-ам), а далее и клиентам.
8. По получении одобрения руководства, код должен быть доставлен в production с возможностью отката примененных изменений, если что-то пойдёт не так. Следовательно, dev, staging и production должны иметь свои репозитории (или ветки?) Git, и "дельта" (накопленные изменения) должна иметь возможность быть быстро отменена.
9. В первое время (сутки) после обновления релиза желательно наблюдать за поведением всей системы, чтобы выявлять возможные неисправности и следить за возникновением "узких мест".
10. Спустя какое-то время после релиза можно собрать фидбэк с конечных пользователей, чтобы учесть его в будущих review.